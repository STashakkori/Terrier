// $t@$h
// QVLx Labs
use rust_cuda::prelude::*;
use regex::Regex;
use walkdir::WalkDir;
use rayon::prelude::*;
use std::process::Command;
use std::collections::{HashMap, HashSet};
use std::fs;
use std::sync::Mutex;
use std::sync::Arc;
use serde::{Serialize, Deserialize};
use std::path::PathBuf;
use std::fs::File;
use std::io::{self, Rea, Write};
use std::error::Error;

#[derive(Serialize, Deserialize, Debug)]
struct DateData {
    dates: HashMap<String, String>,
}

impl DateData {
    fn load(file_path: &PathBuf) -> io::Result<Self> {
        let mut file = File::open(file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        let data: Self = serde_json::from_str(&contents)?;
        Ok(data)
    }

    fn save(&self, file_path: &PathBuf) -> io::Result<()> {
        let mut file = File::create(file_path)?;
        let contents = serde_json::to_string(self)?;
        file.write_all(contents.as_bytes())?;
        Ok(())
    }
}

#[kernel]
fn linear_regression_kernel(data: &[f32], results: &mut [f32]) {
    let i = global_thread_idx();
    
    if i < data.len() / 2 {
        let x = data[2 * i];
        let y = data[2 * i + 1];

        atomic_add(&mut results[0], x);     // Sum of x
        atomic_add(&mut results[1], y);     // Sum of y
        atomic_add(&mut results[2], x * y); // Sum of xy
        atomic_add(&mut results[3], x * x); // Sum of x^2
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let device = Device::nth(0)?;
    let context = Context::create_and_push(ContextFlags::MAP_HOST | ContextFlags::SCHED_AUTO, device)?;

    let date_data_file = PathBuf::from("date_data.json");
    let date_data = Arc::new(Mutex::new(DateData::load(&date_data_file).unwrap_or_else(|_| DateData { dates: HashMap::new() })));

    let keywords = vec![
        "driver", "kernel", "memory", "ethernet", "network", "VxWorks 5", "VxWorks 6",
        "VxWorks 7", "hypervisor", "TCP", "UDP", "flash", "uart", "jtag", "overflow", "stack", "cache",
        "MITM", "Windows", "MacOS", "iOS", "Android", "Xbox", "Printer", "Router", "cellular", "fax",
        "automobile", "medical", "kitchen",
    ];

    // WalkDir and data collection logic
    WalkDir::new(r"exploitdb/exploits")
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.file_type().is_file())
        .par_bridge()
        .for_each_with(date_data.clone(), |date_data, entry| {
            let path = entry.path();
            if let Ok(content) = fs::read_to_string(path) {
                let year = {
                    let mut dd = date_data.lock().unwrap();
                    match dd.dates.get(path.to_str().unwrap()) {
                        Some(year) => year.clone(),
                        None => {
                            let year = get_git_commit_year(path);
                            dd.dates.insert(path.to_str().unwrap().to_string(), year.clone());
                            year
                        }
                    }
                };

                if filter_year == "ALL" || filter_year == year {
                    let mut files_with_keywords = HashSet::new();
                    let mut res = results.lock().unwrap();
                    let year_results = res.entry(year.clone()).or_insert_with(HashMap::new);

                    for &keyword in &keywords {
                        if Regex::new(keyword).unwrap().is_match(&content) {
                            files_with_keywords.insert(keyword);
                        }
                    }

                    for &keyword in files_with_keywords.iter() {
                        *year_results.entry(keyword.to_string()).or_insert(0) += 1;
                    }

                    let mut total_year = total_files_per_year.lock().unwrap();
                    *total_year.entry(year.clone()).or_insert(0) += 1;
                }
            }
        });

    // Save the collected data
    let dd = date_data.lock().unwrap();
    dd.save(&date_data_file)?;

    // Prepare data for CUDA
    let prepared_data = prepare_data_for_cuda(&date_data)?;
    let mut results = vec![0.0; 4];

    unsafe {
        linear_regression_kernel(
            &prepared_data, 
            &mut results,
            grid(1), 
            block(64)
        )?;
    }

    // Calculate regression line
    let n = (prepared_data.len() / 2) as f32;
    let sum_x = results[0];
    let sum_y = results[1];
    let sum_xy = results[2];
    let sum_xx = results[3];

    let m = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
    let b = (sum_y - m * sum_x) / n;

    println!("Regression line: y = {:.2}x + {:.2}", m, b);
    Ok(())
}

fn prepare_data_for_cuda(date_data: &Arc<Mutex<DateData>>) -> Result<Vec<f32>, Box<dyn Error>> {
    let dd = date_data.lock().unwrap();
    
    // Flatten year:count
    let mut data = Vec::new();
    for (year, counts) in dd.dates.iter() {
        let year_float = year.parse::<f32>().unwrap_or(0.0);
        for keyword in &keywords {
            if let Some(&count) = counts.get(keyword) {
                data.push(year_float);
                data.push(count as f32);
            }
        }
    }

    Ok(data)
}

fn get_git_commit_year(path: &std::path::Path) -> String {
    let output = Command::new("git")
        .arg("log")
        .arg("-1")
        .arg("--format=%cd")
        .arg("--date=format:%Y")
        .arg(path.to_str().unwrap())
        .output()
        .expect("Failed to execute git command");
    String::from_utf8_lossy(&output.stdout).trim().to_string()
}
